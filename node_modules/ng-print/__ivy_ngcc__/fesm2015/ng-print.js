import { InjectionToken, PLATFORM_ID, Directive, Inject, Input, HostListener, NgModule } from '@angular/core';
import { isPlatformBrowser, DOCUMENT } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* Create a new injection token for injecting the window into a component. */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
const WINDOW = new InjectionToken('WindowToken');
/* Define abstract class for obtaining reference to the global window object. */
/**
 * @abstract
 */
class WindowRef {
    /**
     * @return {?}
     */
    get nativeWindow() {
        throw new Error('Not implemented.');
    }
}
/* Define class that implements the abstract class and returns the native window object. */
class BrowserWindowRef extends WindowRef {
    constructor() {
        super();
    }
    /**
     * @return {?}
     */
    get nativeWindow() {
        return window;
    }
}
BrowserWindowRef.ɵfac = function BrowserWindowRef_Factory(t) { return new (t || BrowserWindowRef)(); };
BrowserWindowRef.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BrowserWindowRef, factory: BrowserWindowRef.ɵfac });

/* Create an factory function that returns the native window object. */
/**
 * @param {?} browserWindowRef
 * @param {?} platformId
 * @return {?}
 */
function windowFactory(browserWindowRef, platformId) {
    if (isPlatformBrowser(platformId)) {
        return browserWindowRef.nativeWindow;
    }
    return new Object();
}
/* Create a injectable provider for the WindowRef token that uses the BrowserWindowRef class. */
/** @type {?} */
const browserWindowProvider = {
    provide: WindowRef,
    useClass: BrowserWindowRef
};
/* Create an injectable provider that uses the windowFactory function for returning the native window object. */
/** @type {?} */
const windowProvider = {
    provide: WINDOW,
    useFactory: windowFactory,
    deps: [WindowRef, PLATFORM_ID]
};
/* Create an array of providers. */
/** @type {?} */
const WINDOW_PROVIDERS = [
    browserWindowProvider,
    windowProvider
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgPrintDirective {
    /**
     * @param {?} document
     * @param {?} window
     */
    constructor(document, window) {
        this.document = document;
        this.window = window;
    }
    /**
     * @return {?}
     */
    print() {
        /** @type {?} */
        const x = this.document.getElementsByTagName("head")[0].innerHTML;
        /** @type {?} */
        const iframe = this.document.createElement("iframe");
        iframe.style.display = 'none';
        this.document.body.appendChild(iframe);
        iframe.contentWindow.document.write(x);
        iframe.contentWindow.document.write(this.elementToPrint.innerHTML);
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.window.frames[0].print();
        }), 500);
        // remove iframe after print or cancelation
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            var a = this.document.querySelectorAll('iframe');
            a[0].parentNode.removeChild(a[0]);
        }), 500);
    }
}
NgPrintDirective.ɵfac = function NgPrintDirective_Factory(t) { return new (t || NgPrintDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(WINDOW)); };
NgPrintDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgPrintDirective, selectors: [["button", "ngPrint", ""]], hostBindings: function NgPrintDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NgPrintDirective_click_HostBindingHandler() { return ctx.print(); });
    } }, inputs: { elementToPrint: "elementToPrint" } });
/** @nocollapse */
NgPrintDirective.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
NgPrintDirective.propDecorators = {
    elementToPrint: [{ type: Input }],
    print: [{ type: HostListener, args: ['click',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgPrintDirective, [{
        type: Directive,
        args: [{
                selector: "button[ngPrint]"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [WINDOW]
            }] }]; }, { print: [{
            type: HostListener,
            args: ['click']
        }], elementToPrint: [{
            type: Input
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgPrintModule {
}
NgPrintModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgPrintModule });
NgPrintModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgPrintModule_Factory(t) { return new (t || NgPrintModule)(); }, providers: [WINDOW_PROVIDERS], imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgPrintModule, { declarations: [NgPrintDirective], exports: [NgPrintDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgPrintModule, [{
        type: NgModule,
        args: [{
                declarations: [NgPrintDirective],
                imports: [],
                exports: [NgPrintDirective],
                providers: [WINDOW_PROVIDERS]
            }]
    }], null, null); })();

export { NgPrintModule, NgPrintDirective as ɵa, WINDOW as ɵb, WindowRef as ɵc, BrowserWindowRef as ɵd, windowFactory as ɵe, WINDOW_PROVIDERS as ɵf };

//# sourceMappingURL=ng-print.js.map