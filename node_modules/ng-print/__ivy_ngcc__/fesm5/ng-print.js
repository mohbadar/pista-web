import { InjectionToken, PLATFORM_ID, Directive, Inject, Input, HostListener, NgModule } from '@angular/core';
import { isPlatformBrowser, DOCUMENT } from '@angular/common';
import { __extends } from 'tslib';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* Create a new injection token for injecting the window into a component. */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
var WINDOW = new InjectionToken('WindowToken');
/* Define abstract class for obtaining reference to the global window object. */
/**
 * @abstract
 */
var  /* Define abstract class for obtaining reference to the global window object. */
/**
 * @abstract
 */
WindowRef = /** @class */ (function () {
    function WindowRef() {
    }
    Object.defineProperty(WindowRef.prototype, "nativeWindow", {
        get: /**
         * @return {?}
         */
        function () {
            throw new Error('Not implemented.');
        },
        enumerable: true,
        configurable: true
    });
    return WindowRef;
}());
/* Define class that implements the abstract class and returns the native window object. */
var  /* Define class that implements the abstract class and returns the native window object. */
BrowserWindowRef = /** @class */ (function (_super) {
    __extends(BrowserWindowRef, _super);
    function BrowserWindowRef() {
        return _super.call(this) || this;
    }
    Object.defineProperty(BrowserWindowRef.prototype, "nativeWindow", {
        get: /**
         * @return {?}
         */
        function () {
            return window;
        },
        enumerable: true,
        configurable: true
    });
BrowserWindowRef.ɵfac = function BrowserWindowRef_Factory(t) { return new (t || BrowserWindowRef)(); };
BrowserWindowRef.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BrowserWindowRef, factory: function (t) { return BrowserWindowRef.ɵfac(t); } });

    return BrowserWindowRef;
}(WindowRef));
/* Create an factory function that returns the native window object. */
/**
 * @param {?} browserWindowRef
 * @param {?} platformId
 * @return {?}
 */
function windowFactory(browserWindowRef, platformId) {
    if (isPlatformBrowser(platformId)) {
        return browserWindowRef.nativeWindow;
    }
    return new Object();
}
/* Create a injectable provider for the WindowRef token that uses the BrowserWindowRef class. */
/** @type {?} */
var browserWindowProvider = {
    provide: WindowRef,
    useClass: BrowserWindowRef
};
/* Create an injectable provider that uses the windowFactory function for returning the native window object. */
/** @type {?} */
var windowProvider = {
    provide: WINDOW,
    useFactory: windowFactory,
    deps: [WindowRef, PLATFORM_ID]
};
/* Create an array of providers. */
/** @type {?} */
var WINDOW_PROVIDERS = [
    browserWindowProvider,
    windowProvider
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgPrintDirective = /** @class */ (function () {
    function NgPrintDirective(document, window) {
        this.document = document;
        this.window = window;
    }
    /**
     * @return {?}
     */
    NgPrintDirective.prototype.print = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var x = this.document.getElementsByTagName("head")[0].innerHTML;
        /** @type {?} */
        var iframe = this.document.createElement("iframe");
        iframe.style.display = 'none';
        this.document.body.appendChild(iframe);
        iframe.contentWindow.document.write(x);
        iframe.contentWindow.document.write(this.elementToPrint.innerHTML);
        setTimeout((/**
         * @return {?}
         */
        function () {
            _this.window.frames[0].print();
        }), 500);
        // remove iframe after print or cancelation
        setTimeout((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var a = _this.document.querySelectorAll('iframe');
            a[0].parentNode.removeChild(a[0]);
        }), 500);
    };
    /** @nocollapse */
    NgPrintDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    NgPrintDirective.propDecorators = {
        elementToPrint: [{ type: Input }],
        print: [{ type: HostListener, args: ['click',] }]
    };
NgPrintDirective.ɵfac = function NgPrintDirective_Factory(t) { return new (t || NgPrintDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(WINDOW)); };
NgPrintDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgPrintDirective, selectors: [["button", "ngPrint", ""]], hostBindings: function NgPrintDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NgPrintDirective_click_HostBindingHandler() { return ctx.print(); });
    } }, inputs: { elementToPrint: "elementToPrint" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgPrintDirective, [{
        type: Directive,
        args: [{
                selector: "button[ngPrint]"
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [DOCUMENT]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [WINDOW]
            }] }]; }, { print: [{
            type: HostListener,
            args: ['click']
        }], elementToPrint: [{
            type: Input
        }] }); })();
    return NgPrintDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgPrintModule = /** @class */ (function () {
    function NgPrintModule() {
    }
NgPrintModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgPrintModule });
NgPrintModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgPrintModule_Factory(t) { return new (t || NgPrintModule)(); }, providers: [WINDOW_PROVIDERS], imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgPrintModule, { declarations: [NgPrintDirective], exports: [NgPrintDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgPrintModule, [{
        type: NgModule,
        args: [{
                declarations: [NgPrintDirective],
                imports: [],
                exports: [NgPrintDirective],
                providers: [WINDOW_PROVIDERS]
            }]
    }], function () { return []; }, null); })();
    return NgPrintModule;
}());

export { NgPrintModule, NgPrintDirective as ɵa, WINDOW as ɵb, WindowRef as ɵc, BrowserWindowRef as ɵd, windowFactory as ɵe, WINDOW_PROVIDERS as ɵf };

//# sourceMappingURL=ng-print.js.map